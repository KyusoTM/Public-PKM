# SELECT句に含まれない要素に対するORDER BYの挙動

【結論】

**`DISTINCT`句を用いる場合**，`ORDER BY`に指定できる要素は`SELECT`句で指定された要素に限られる.
```sql
SELECT DISTINCT
    c1,
    c2
FROM tableA
ORDER BY c3 --このc3は無視される
```

## 背景
paizaの口座([[📗新SQL入門編17_(ビジネス編)月ごと時間ごとに集計しよう]])の演習問題取組中に，
サブクエリを用いて回答の[[SQL文]]を記述していた．

【該当コード】
```sql
SELECT
    CASE
        WHEN day_of_week = 0 THEN '日曜日'    
        WHEN day_of_week = 1 THEN '月曜日'
        WHEN day_of_week = 2 THEN '火曜日'
        WHEN day_of_week = 3 THEN '水曜日'
        WHEN day_of_week = 4 THEN '木曜日'
        WHEN day_of_week = 5 THEN '金曜日'
        WHEN day_of_week = 6 THEN '土曜日'
        ELSE NULL    
    END AS 売上曜日,
    SUM(amount) AS 合計金額
FROM(
    SELECT
        DATE_FORMAT(sales_date, "%w") AS day_of_week ,
        sales_date,
        amount
    FROM sales
) AS 売上
GROUP BY day_of_week
ORDER BY day_of_week;
```

この時，[[MySQLのSQL実行順序]]では`SELECT`句の後ろにある`ORDER BY`句に，`SELECT`句では選択されていない`day_of_week`要素を使って整列を行っていた．

[[SQL文]]としては，想定した通りの並べ替えが実行されていたが，処理上でのテーブルの扱いと`ORDER BY`に`SELECT`句で指定していない値を導入してよいのかが気になった．

## 調査結果
[[MySQL]]の公式リファレンス[^1]には以下の記述がある(機械翻訳)

> 結果を並べ替えるには、最初に重複を排除する必要があります。 ただし、そのためには、最初の行または 3 番目の行を保持する必要がありますか。 この任意の選択は c3 の保持された値に影響し、これは順序付けに影響を与え、任意にすることもできます。 この問題を回避するために、いずれかの ORDER BY 式が次のいずれかの条件を満たさない場合、DISTINCT および ORDER BY を含むクエリーは無効として拒否されます:
>
> - 式が選択リストの式と等しい
>
> - 式によって参照され、クエリーで選択されたテーブルに属するすべてのカラムは、選択リストの要素です

[[Oracle Database]]でも同様らしい[^2]

[^1]: MySQL 8.0 リファレンスマニュアル: [12.20.3 MySQL での GROUP BY の処理](https://dev.mysql.com/doc/refman/8.0/ja/group-by-handling.html)
[^2]: ORACLE 技術リソース: [テクノロジー: SQLの基礎](https://www.oracle.com/jp/technical-resources/articles/sql101/o32sql.html#:~:text=%EF%BC%9AORDER%20BY%E3%81%AE%E5%88%97%E3%81%8CSELECT%E6%A7%8B%E6%96%87%E3%81%AE%E3%83%AA%E3%82%B9%E3%83%88%E3%81%AB%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%E3%81%AB%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%8C%E7%99%BA%E7%94%9F%E3%81%99%E3%82%8BDISTINCT%E3%82%92%E6%8C%87%E5%AE%9A%E3%81%97%E3%81%9F%E5%95%8F%E5%90%88%E3%81%9B)

この仕様に関して言及したブログ[^3]によると，以下の方法で`ORDER BY`に`SELECT`していないカラムを設定できるらしい．

> - selectリストにORDER BY項目を追加
> - ORDER BY項目にselectリストのカラムを追加
> - ONLY_FULL_GROUP_BY モードを無効にする
> - サブクエリでORDER BY項目ありのselect distinctをし、外側でORDER BYする

おそらくそれぞれが，以下の仕組みで対策をしていると思われる．

- > selectリストにORDER BY項目を追加
  - そもそも項目を`SELECT`すればよい．
- > ORDER BY項目にselectリストのカラムを追加
  - よくわからない
  - `SELECT`されているデータを使えということ?
- > ONLY_FULL_GROUP_BY モードを無効にする
  - エラーの条件として`ONLY_FULL_GROUP_BY`が有効化されている必要がある[^1]ため，無効化すると動作が実現できる．
- > サブクエリでORDER BY項目ありのselect distinctをし、外側でORDER BYする
  - `DISTINCT`されているクエリでのみエラーが出るため，サブクエリに実行させればよい．

[^3]: Qiita: [MySQL5.6->MySQL8.0へのバージョンアップで対応したこと4つ](https://qiita.com/shibuchaaaan/items/26976503bf0d4a707ae7)

今回の演習課題に関しては，`DISTINCT`の指定を行わなかったために`SELECT`していないカラムでの`ORDER BY`が認識されていたとも解釈できる．(そもそも，どのタイミングで取得テーブルの内容が変わっているのか?)
- 他の考えられるパターン
  - `CASE`で使用されているカラムのため，影響がなかった
  - `GROUP BY`で使用されていたカラムのため，影響がなかった

## 結論
[[SQL文]]において`SELECT`句に指定していないカラムであっても`ORDER BY`で指定することは可能．ただし，`DISTINCT`を指定した場合は`SELECT`句に指定されていない要素での並べ替えは不可となる．


[//begin]: # "Autogenerated link references for markdown compatibility"
[SQL文]: SQL%E6%96%87.md "SQL文"
[MySQLのSQL実行順序]: MySQL%E3%81%AESQL%E5%AE%9F%E8%A1%8C%E9%A0%86%E5%BA%8F.md "MySQLのSQL実行順序"
[//end]: # "Autogenerated link references"