# 📰シリアル通信でマルチスレッドが必要な理由の調査

## keyword
- シリアル通信の非同期性
- PythonのGIL
- 

## 考察1 : readメソッドによるスレッド停止
以下のライブラリにおいてserial通信時のreadメソッドは，データの受信が行われる(or タイムアウト)までは，実行されているスレッドの処理を停止させる仕様となっていた．
- [[PySerial]]: ([[Python]])
- Arduino.h: ([[C++]])

このスレッド停止により，以降の処理が実施されない結果，受信タイミングを逃した場合にプログラムがフリーズしうると考えられる．

## 考察2 : シリアル通信の仕様によるもの
### copilotに聞いてみた : ([[2024-06-27#pyserialのマルチスレッドについてcopilotに聞いてみた|daily-note]])
> 【質問】
> pythonのpyserialを用いたデータ受信において，read()関数をマルチスレッドで実行しないと，データの受信が安定して行えません． その理由について説明してください．

> 【解答】
> シリアル通信の非同期性: シリアル通信は基本的に非同期であり、データはいつでも送信される可能性があります。したがって、データが到着したときにすぐにそれを読み取るためには、read()関数を常に実行する必要があります。これを単一のスレッドで行うと、他のタスク（例えばデータの処理やユーザーインターフェースの更新など）がブロックされてしまう可能性があります。しかし、read()関数を別のスレッドで実行することで、データの受信と他のタスクを並行して行うことができ、データの受信が安定します。

関連
- [[PySerial]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[PySerial]: ../Literature/PySerial.md "PySerial"
[//end]: # "Autogenerated link references"